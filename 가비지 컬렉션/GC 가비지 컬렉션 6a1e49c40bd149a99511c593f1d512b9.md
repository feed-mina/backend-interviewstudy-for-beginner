# GC 가비지 컬렉션

> **Garbage Collection (GC)이란?**
> 

**가비지 컬렉션(Garbage Collection 이하 GC)는 자바의 메모리 관리 방법 중의 하나로 JVM(자바 가상 머신)의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스를 말한다.**

![Untitled](GC%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206a1e49c40bd149a99511c593f1d512b9/Untitled.png)

Java에서는 가바지 컬렉터가 메모리 관리를 대행해주기 때문에 Java프로세스가 한정된 메모리를 효율적으로 사용할 수 있게 하고 개발자 입장에서 메모리 관리, 메모리 누수 문제에서 대해 관리하지 않아도 되어 오롯이 개발에만 집중 할 수 있다는 장점이 있다.

단점으로 자동으로 처리해준다 해도  메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며 가비지 컬렉션(GC)가 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. 이를 Stop-The-World(STW)라한다.

> STW (Stop The Wrold)
> 
- GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미, GC가 작동하는 동안 GC관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있다. 따라서 이 시간을 최소화 시키는것이 쟁점이다.

- 가비지 컬렉션 대상 은 어떤 Object를 Garbage로 판단해서 스스로 지울까? 가비지 컬렉션은 특정 객체가 garbage인지 아닌지 판단하기 위해서 도달성, 도달 능력(Reachablity)이라는 개념을 적용한다. 객체에 레퍼런스가 있다면 Reachable로 구분되고 객체에 유효한 레퍼런스가 없다면 Unreachable로 구분해버리고 수거해버린다.

1.Reachable : 객체가 참조되고 있는 상태

2.Unreachable : 객체가 참조되고 있지 않은 상태 (GC의 대상이 됨)

![Untitled](GC%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206a1e49c40bd149a99511c593f1d512b9/Untitled%201.png)

예를 들어 JVM메모리에서는 객체들은 실질적으로 Heap영역에서 생성되고 Method Area나 Stack Area에서는 Heap Area에 생성된 객체의 주소만 참조하는 형식으로 구성된다. 하지만 이렇게 생성된 Heap Area의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상이 발생하면 위의 그림에서의 빨간색 객체와 같이 Heap영역에서 어디서든 참조하고 있지 않는 객체(Unreachable)들이 발생하게 된다. 이러한 객체들을 주기적으로 가비지 컬렉터가 제거해주는 것이다.

> 가비지 컬렉션 청소 방식
> 

GC가 Unreachable한 객체를 어떤 방식으로 청소를 하는지 알아보자.

- Mark And Sweep

Mark-Sweep이란 다양한 GC에서 사용되는 객체를 속아내는 내부 알고리즘이다. 가비지 컬렉션이 동작하는 아주 기초적인 청소 과정이라고 생각하면 된다.

![Untitled](GC%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206a1e49c40bd149a99511c593f1d512b9/Untitled%202.png)

![https://blog.kakaocdn.net/dn/cgSNa1/btrIVgyOGYA/509WaRQ5LIjGdfNbduIMJ0/img.gif](https://blog.kakaocdn.net/dn/cgSNa1/btrIVgyOGYA/509WaRQ5LIjGdfNbduIMJ0/img.gif)

```
가비지 컬렉션이 될 대상 객체를 식별(Mark)하고 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행하게 된다. 
Mark 과정 : 먼저 Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
Sweep 과정 : 참조하고 있지 않은 객체 즉 Unreachable객체들을 Heap에서 제거한다.
Compact 과정 : Sweep후에 분산된 객체들을 Heap의 시작주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다. (가비지 컬렉터 종류에 따라 하지 않는 경우도 있음)
이렇게 Mark And Sweep 방식을 사용하면 루트로부터 연결이 끊긴 순환 참조 되는 객체들을 모두 지울 수 있다. 

```

> Heap 메모리 의 구조
> 

JVM의 힙(heap)영역은 동적으로 레퍼런스 데이터가 저장되는 공간으로서 가비지 커렉션에 대상이 되는 공간이다. Heap영역은 처음 설계될때 다음의 2가지 전제(Weak Gerational Hyposhesis)로 설계되었다. 1) 대부분의 객체는 금방 접근 불가능한 상태 (Unreachable)가 된다. 2)오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다. 즉, 객체는 대부분 일회성되며 메모리에 오랫동안 남아있는 경우는 드물다는 것이다. 이러한 특성을 이용해 JVM개발자들은 보다 효율적인 메모리 관리를 위해 객체의 생존기간에 따라 물리적인 Heap영역을 나누게 되었고Young 과 Old 총 2가지 영역으로 설계하였다.