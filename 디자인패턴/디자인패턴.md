### 전략패턴(Strategy Pattern)
여러 알고리즘을 하나의 추상적인 접근점(Interface)를 만들어 접근접에서 서로 교환 가능(Deligate)하도록 하는 패턴
사용자(Client)는 자신에게 맞는 전략(Strategy)를 취사선택하여 로직을 수행할 수 있게 하는 방법이다. 
게임을 예로 들면 캐릭터는 공격이라는 작업을 수행함에 있어 무기를 상황에 맞게 선택해서 공격을 위임할 수 있다.
![image](https://github.com/feed-mina/backend-interviewstudy-for-beginner/assets/97416996/c0cd61f3-871e-4d49-adaf-febfb5bca7d2)


```java
// Weapon.java
public interface Weapon {
    public void attack();
}


// Knife.java
public class Knife implements Weapon{

    @Override
    public void attack() {
        System.out.println("칼 공격");
    }
}


// Sward.java
public class Sword implements Weapon{
    @Override
    public void attack() {
        System.out.println("검 공격");
    }
}


//GameCharacter.java
public class GameCharacter {
    //접근점 무기는 공격이라는 기능을 가지는 하나의 접근점이 된다.
    private Weapon weapon;

    //교환 가능 setWeapon 매서드를 통해 접근점을 변경 할 수 있다.
    public void setWeapon(Weapon weapon) {
        this.weapon = weapon;
    }
    public void attack(){
        if (weapon == null) {
            System.out.println("맨손 공격");
        } else {
            //위임(Delegate) wapon.attack()으로 wepon에게 공격기능을 위임한다.
            weapon.attack();
        }
    }
} 

//main.java
public class main {
    public static void main(String[] args) {
        GameCharacter character = new GameCharacter();
        character.attack();

        character.setWeapon(new Knife());
        character.attack();

        character.setWeapon(new Sword());
        character.attack();
    }
}

```
#### 장점 : 전략패턴의 가장 큰 장점은 확장성이다. wapon이라는 인터페이스를 상속해서 같은 기능(책임)만 수행 할 수 있다면 얼마든지 다른 무기도 추가할 수 있다. 
 

### 어댑터 패턴(Adapter Pattern)
클라이언트의 요구 타입과 반환 타입이 다를지라도 중간에 어댑터를 둠으로써 적절히 가공하여 둘을 연결지어 준다. 어댑터 패턴을 사용하면 전혀 다른 인자값을 가지고도 몇몇 알고리즘을 사용해서 로직을 수행 할 수 있다.
```java
// 기존에 보유하고 있는 알고리즘 Math.java
public class Math{
    public static double twoTime(double num){
        return num * 2;
    }

    public static double half(double num){
        return num / 2;
    }
} 
```

* 기존에 double 타입의 값을 받아 두배로 반환하는 twoTime 매서드와 절반을 반환하는 half가 있다.
* 요구사항 1) Float 인자값을 받아서 수의 두배를 Float 타입으로 변환하는 twiceOf 매서드 구현 , 2) Float 인자값을 받아서 수의 절반을 Flat 타입으로 변환하는 halfOf 매서드 구현, 구현객체명은 Adapter로 명명
```java
// Adapter.java
public interface Adapter{
    public Float twiceOf(Float f);
    public Float halfOf(Float f);
}
// Adapter Interface 및 매서드 작성

// AdapterImpl.java
public class AdapterImpl implements Adapter{
    @Override
    public Float twiceOf(Float f){
        return (float) Math.twoTime(f.doubleValue());
    }

    @Override
    public Float halfOf(Float f){
        return (float) Math.half(f.doubleValue());
    }
}

// main.java 기존에 존재하던 twoTime, half 매서드를 이용해서 전혀 다른 인자값을 받아 로직을 수행하도록 완성
public class main{
    public static void main(String[] args){
        Adapter adapter = new AdapterImpl();
        System.out.println(adapter.twiceof(100f)); // 200.0
        System.out.println(adapter.halfOf(50f)); // 25.0
    }
} 
```

Adapter라는 객체를 사용해서 twoTime, half매서드의 알고리즘을 수행한다. 이로써 사용자는 ADapter의 twiceOF와 half만 사용하면 그 내부에서 어떤 알고리즘을 사용하던 맞는 결과만 반환하면 된다. 그 말은 나중에 twiceOf()매서드가 Deprecated되고 더 나은 알고리즘이 나오면 해당 알고리즘을 사용하도록 해도 사용자 입장에서는 크게 사용방법이 달라지지 않는다는 장점이 있다. 그리고 특정 알고리즘 전후로 부가 기능을 추가 될 수도 있다.

#### 장점 : 연관 없는 두 객체를 연결해서 원하는 요구 사항을 수용한다면 생산성 측면에서도 더 높아질 수 있다. 이를 통해 우리는 매번 요구사항 마다 새로운 알고리즘을 만들거나 타입별로 비슷한 알고리즘들을 새로 구현할 필요 없이 기존의 알고리즘을 변형해 재활용 할 수 있게 된다. 예를 들어 리스트(ArrayList) 컬렉션을 버블정렬을 해야 하는 요구사항이 생겼을때 나한테 배열을 기준으로 버블정렬을 구현한 알고리즘이 있다면 굳이 리스트컬랙션을 이용한 새로운 알고리즘을 구현할 필요 없이 리스트를 배열로 만들어서 알고리즘을 수행한 후 다시 리스트 컬랙션으로 변화할 수 있다.
 
### 템플릿 메소드 패턴(Template Method Pattern)
템플릿은 비유하자면 일종의 붕어빵 틀, 타꼬야키 틀과 비슷하다고 불 수 있으며 알고리즘의 구조를 메소드에 정의하고 하위 클래스에서 알고리즘 구조의 변경 없이 알고리즘을 재정의 하는 패턴이다.

#### 사용처 : 일정한 프로세스를 가진 요구사항을 탬플릿 메소드 패턴을 이용하여 구현 할 수 있다.
ex) Spring Security의 인증 및 인가 과정, 애노테이션 프로세서의 라운드 구조, 로직의 완성까지의 순차적인 일정한 단계가 있는 등
* 시민들을 징집해서 병사로 만들기 : conscription():Solider
##### 1. 시민들 중 마린이 될 수있는 조건의 시민을 징집 : conscriptionCitizen(): citizen
##### 2. 징집된 군인들을 훈련 : traning(Citizen) : void
##### 3. 보직을 시민에서 병사로 변경 : changeOfPosition(Citizen citizen) : Solider
##### 4. 장비를 보급 : SupplyEquipment(Soldider solider);

요구사항은시민들을 징집해 병사로 만들라는 요구사항이다. 그리고 시민을 징집해 병사가 되기 까지의 과정을 생각하면 위와 같은 일련의 과정들을 거쳐야 한다. 
각 과정 (process)를 가지고 각각의 알고리즘들은 차후 변경될 가능성도 있다. (ex- 훈련의 내용이 바뀐다. 보급하는 장비가 변경된다 등등)
![image](https://github.com/feed-mina/backend-interviewstudy-for-beginner/assets/97416996/cc9984f4-dde9-4129-829f-793531d8049f)

```java
// AbstSoliderConscriptionHelper.java

package city.army;
import city.citizen;
public abstract class AbstSoliderConscriptionHelder{
    protected abstract Citizen conscriptionCitizen(); // 시민들 중 마린이 될 수 있는 조건의 시민 징집을 한다.
    protected abstract void training(Citizen citizen); // 징집된 군인들을 훈련한다.
    protected abstract Solider chageOfPosition(Citizen citizen); // 장비를 보급한다. 

    public Solider conscription(){
        Citizen citizen = conscriptionCitizen();
        training(citizen);
        Solider solider = chageOfPosition(citizen);
        supplyEquipment(solider);
        return solider;
    }
}

// SoliderConscriptionHelperImpl.java
package city.army;
import city.Citizen;
import city.army.armor.SteelAmor;
import city.army.weapon.Gun;

public class SoliderConscriptionHelperImpl extends AbstSoliderConscriptptionHelper{
    @Override
    protected Citizen conscriptionCitizen(){
        System.out.println("징집!");
        return new Citizen(); 
    }

    @Override
    protected void training(Citizen citizen){
        citizen.updateStrength(5);
        citizen.updateAgility(4);
        citizen.updateIntelligence(-3);
        System.out.println("병사 훈련");

    }

    @Override
    protected void supplyEquipment(Solider solider){
        solider.setWeapon(new Gun());
        solider.setArmor(new SteelAmor());
        System.out.println("장비보급");
    }


    @Override
    protected Solider changeOfPosition(Citizen citizen){
        System.out.println("시민 => 병사 변경!");
        return new Solider(citizen);
    }
}
```
#### 기타 구현 코드

```java
/// Citizen.java
package city;
public class Citizen{
    private String id;
    private int age;
    private String name;
    private STring position;
    private int strength;
    private int agility;
    private int intelligence;

    @Override
    public String toString(){
        return "Citizen{" +
        "id='" + id + '\''+
        ", age=" + age +
        ", name='" + name + '\''+
        ", position-'" + position + '\'' +
        ", agility=" + agility +
        ", intelligence=" + intelligence +
        '}';
    }
    
    public Citizen(Citizen citizen){
        this.id = citizen.getId();
        this.age = citizen.getAge();
        this.name = citizen.getName();
        this.position = citizen.getPosition();
        this.strength = citizen.getStrength();
        this.agility = citizen.getAgility();
        this.intelligence = citizen.getintelligence();
    }

    public void updateStrength(int stat){
        strength += stat;
    }
    public void updateAgility(int stat){
        agility += stat;
    }
    public void updateIntelligence(int stat){
        intelligence += stat;
    }


    public Citizen(String id, int age, String name, String position, int strength, int agility, int intelligence){
        this.id = id;
        this.age = age;
        this.name = name;
        this.position = position;
        this.strength = strength;
        this.agility = agility;
        this.intelligence = intelligence;
    }

    public Citizen(){

    }

    public String getPosition(){
        return position;
    }

    public void setPosition(String pisition){
        this.position = position;
    }

    public String getId(){
        return id;
    }

    public int getAge(){
        return age;
    }

    public String getName(){
        return name;
    }

    public int getStrength(){
        return strength;
    }

    public int getAgility(){
        return agility;
    }

    public int getIntelligence(){
        return intelligence;
    }
 
    }
}
// Armor.java
package city.army.armor;
public interface Armor{
    public void defence();
}

// Solider.java
package city.army;

import city.Citizen;
import city.army.armor.Armor;
import city.army.weapon.Weapon;

public class Soldier extends Citizen {
    private Weapon weapon;
    private Armor armor;

    public void attack(){
        if(weapon == null){
            System.out.println("맨손 공격");
        }
        weapon.attack();
    }
    public void defense(){
        if (armor == null) {
            System.out.println("맨몸으로 방어!");
        }
        armor.defense();
    }



    public Soldier() {
        super();
    }

    public Soldier(Weapon weapon, Armor armor) {
        this.weapon = weapon;
        this.armor = armor;
    }

    public Soldier(Citizen citizen) {
        super(citizen);
    }

    public Armor getArmor() {
        return armor;
    }

    public void setArmor(Armor armor) {
        this.armor = armor;
    }

    public Weapon getWeapon() {
        return weapon;
    }

    public void setWeapon(Weapon weapon) {
        this.weapon = weapon;
    }

    @Override
    public String toString() {
        super.toString();
        return "Soldier{" +
                "weapon=" + weapon +
                ", armor=" + armor +
                '}';
    }
}


// SteelArmor.java
package city.army.armor;
public class SteelAmor implements Armor{
    @Overrice
    pubic void defense(){
        System.out.println("갑옷방어!");
    }
}

// Weapon.java
package city.army.weapon;
public interface Weapon{
    public void attack();
} 
// Gun.java
package city.army.weapon;
public class Gun implements Weapon{
    @Override
    public void attack(){
        System.out.println("빵야빵야");
    }
}

// 실행코드
public class main{
    public static void main(String[] args){
        Citizen h1 = new Citizen();
        AbstSoliderConscriptionHelper helper = new SoliderConscriptionHelperImpl();
        Solider solider = helper.conscription();
        solider.attack();
        solider.defense();
    }
}

```
위와 같이 구현을 하게 되면 각각의 상세 요구사항들을 모듈화 했기 때문에 재사용성을 높히고 강화되거나 변경된 정책이나 요구사항을 적용하기가 더 편해진다.
예를 들어 훈련내용이 변경되어 근력강화 훈련을 줄이고 지능 강화훈련을 높혀서 시미의 스탯변경을 바꾸려고 하면 SoliderConscriptionHelperImpl 구현체의 training 메서드 내용만 변경하면 된다.

이처럼 일정한 프로세스를 가진 요구사항을 알고리즘으로 정의할때 
알고리즘의 구조를 메소드에 정의 후 하위 클래스에서 알고리즘 구조의 변경 없이 알고리즘을 재정의 하는 패턴을 
템플릿 메서드 패턴이라 한다. 


#### 팩토리 메소드 패턴(Factory Method Pattern)
객체를 만들어내는 부분을 서브 클래스(SUB-CLASS)에 위임하는 패턴 
즉 new 키워드를 호출해 객체를 생성하는 역할을 서브클래스에 위임하는 것이다. 
결국 팩토리 메소드 패턴은 객체를 만들어내는 공장을 만드는 패턴이라 할 수 있다.
팩토리 메소드 패턴에서는 인스턴스를 만드는 방법을 상위 클래스 측에서 결정하지만 
구체적인 클래스명까지는 결정하지 않는다.
구체적인 내용은 모두 하위 클래스측에서 수행한다. 따라서 인스턴스 생성을 위한 골격(framework)와 실제의 인스턴스 생성의 클래스를 분리해서 생각 할 수 있다.

ex) 신분증 (IDCard)를 만드는 공장을 주제로 코드를 작성한다. 작성할 클래스 중 framework에 속할 Product 와 Factory가 있다. 그리고 구체적인 구현 클래스인 IDCard 와 IDCardFactory를 구현한다.
![image](https://github.com/feed-mina/backend-interviewstudy-for-beginner/assets/97416996/a931a340-ea5d-43c7-b453-1b090df14df7)

- 골격에서는 제품의 골격인 Product와 제품을 생성하는 Factory 가 있다.
Factory에서는 제품을 생성한다. -> create
-> create 함수 내부는 일련의 과정의 알고리즘이기에 템플릿 메서드 패턴(template method pattern)이 가능하다.
- 실제로 제품 인스턴스 생성 메서드 -> createProduct
- 신분증 소유자 등록 메서드 -> registerProduct
- Product에서는 제품을 사용한다 -> use

```java
//framework / Product.java
package com.hansol.framework;
public abstract class Product{
    public abstract void use();
}

// framework / Factory.java
package com.hansol.framework;

public abstract class Factory{
    public final Product create(String owner){
        product p = createProduct(owner);
        registerProduct(p);
        return p;
    }

    protected abstract Product createProduct(String owner);
    protected abstract void registerProduct(Product p);

}

// idcard / IDCard.java
package com.hansol.idcard;
import com.hansol.framework.Product;
public class IDCard extends Product{
    private String owner;

    public IDCard(String owner){
        System.out.println(owner + "의 카드를 만듭니다.");
        this.owner = owner;
    }

    @Override
    public void use(){
        System.out.println(owner+"의 카드를 사용합니다.");
    }

    public string getOwner(){
        return owner;
    }

}

// idcard / IDCardFactory

package com.hansol.idcard;
import com.hansol.framework.Factory;
import com.hansol.framework.Product;

import java.util.ArrayList;
import java.util.List;

public class IDCardFactory extends Factory{
    private List owners = new ArrayList();

    @Override
    protected Product createProduct(String owner){
        return new IDCard(owner);
    }

    @Override
    protected void registerProduct(Product p){
        owners.add(((IDCard)P).getOwner());
    }

    public List getOwners(){
        return owners;
    }

}

// Main.java

package com.hansol;
import com.hansol.framework.Factory;
import com.hansol.framework.product;
import com.hansol.idcard.IDCardFactory;

public class Main{
    public static void main(String[] args){
        Factory factory = new IDCardFactory();
        Product card1 = factory.create("이한솔");
        Product card2 = factory.create("손미정");
        card1.sue();
        card2.use();
    }
}

```

#### 각 클래스의 역할
##### Product(제품) : framework에 포함되어 있다. 이 패턴에서 생성되는 인스턴스가 가져야 할 인터페이스 (API)를 결정하는것을 추상클래스이다. 구체적인 내용(구현부)는 ConcreteProduct 역할이 결정한다. 

##### Creator(작성자) -> 예제에서는 Factory 
Product역할을 생헝하는 추상 클래스는 framework 쪽에 가깝습니다. 구체적인 내용(구현부)은 concreteCreator역할이 결정된다. Factory 클래스가 이 역할을 수행한다. 
Creator 역할을 실제로 생성하는 ConcreateProduct역할에 가지고 있는 정보가 없다. Creator 역할이 가지고 있는 정보는 Product 역할과 인스턴스 생성의 메소드를 호출하면 PRoduct가 생성되는것 뿐이다.
new 를 사용해서 실제의 인스턴스를 생성하는 대신에 인스턴스 생성을 위한 메소드를 호출해서 구체적인 클래스 이름에 의한 속박에서 상위 클래스를 자유롭게 만든다.

ConcreateProduct(구체적인 제품) : 구체적인 제품을 결정하며 idcard쪽에 해당한다. 여기서는 IDCard클래스가 이 역할을 수행한다.
ConcreateCreator(구체적인 작성자) : 구체적인 제품을 만드는 클래스를 결정하며 idCard쪽에 해당된다. IDCardFActory 클래스가 이 역할을 수행한다.
#### framework패키지는 하위패키지에 의존하지 않다고 할 수 있다.

### 인스턴스 생성 - 매소두의 구현 방법
Factory 클래스의 createProduct 메소드는 추상 메소드이고 하위 클래스 (IDCardFactory)에서 구현한다. 
createProduct 메소드의 기술 방법은 크게 세가지 방법으로 구현이 가능하다.

##### 1. 추상 메소드로 구현 : 추상메소드로 하면 하위 클래드에서는 이 메소드를 무조건 오버라이딩 해서 구현해야 한다. 구현하지 않을 경우 컴파일 시점에서 검출된다. 
```java
protected abstract Product createProduct(String owner);
```

##### 디폴트의 구현을 준비 : 하위클래스(구현 클래스)에서 해당 메소드를 구현하지 않았을 경우를 대비해 기본적인 로직을 넣어서 구현을 해두는 방식이다. 하지만 해당 방법의 경우 Product 클래스에  대해서 직접 new를 이요앟고 있어서 Product클래스를 추상 클래스로 둘 수 없다.
```java
protected Product createProduct(String name){
    return new Product(name);
}
```

##### 에러를 이용한다. : 디폴트의 구현 내용을 에러로 처리해두면 하위 클래스에서 구현하지 않았을 경우 실행할때 에러가 발생한다.
```java
protected Product createProduct(String name){
	throw new Exception(...);
}

```
